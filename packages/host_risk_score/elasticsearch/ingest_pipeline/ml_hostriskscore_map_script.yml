---
script:
  lang: painless
  source: |-
    // Get the host variant
    if (state.host_variant_set == false) {
        if (doc.containsKey("host.os.full") && doc["host.os.full"].size() != 0) {
            state.host_variant = doc["host.os.full"].value;
            state.host_variant_set = true;
        }
    }
    // Aggregate all the tactics seen on the host
    if (doc.containsKey("signal.rule.threat.tactic.id") && doc["signal.rule.threat.tactic.id"].size() != 0) {
        state.tactic_ids.add(doc["signal.rule.threat.tactic.id"].value);
    }
    // Get running sum of time-decayed risk score per rule name per shard
    String rule_name = doc["signal.rule.name"].value;
    def stats = state.rule_risk_stats.getOrDefault(rule_name, [0.0,"",false]);
    int time_diff = (int)((System.currentTimeMillis() - doc["@timestamp"].value.toInstant().toEpochMilli()) / (1000.0 * 60.0 * 60.0));
    double risk_derate = Math.min(1, Math.exp((params.lookback_time - time_diff) / params.time_decay_constant));
    stats[0] = Math.max(stats[0], doc["signal.rule.risk_score"].value * risk_derate);
    if (stats[2] == false) {
        stats[1] = doc["kibana.alert.rule.uuid"].value;
        stats[2] = true;
    }
    state.rule_risk_stats.put(rule_name, stats);
